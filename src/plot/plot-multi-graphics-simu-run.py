# # !/usr/bin/python
# # -*- coding: utf-8 -*-
# #
# # simu-plot -- Plot a workload schedule
# #
# # Given a system configuration, a workload description, and a schedule as
# # generated by simulation, this program generates a plot displaying the
# # amount of gpus used by each job over time, as well as submission times
# # for each job in the workload.
# #
# # Copyright Â© 2017 Marcelo Amaral <marcelo.amaral@bsc.es>
#
import argparse
import configparser
import copy
import itertools
import json
import math
import matplotlib
import matplotlib.pyplot as plt
import os
from collections import OrderedDict
from matplotlib.ticker import AutoMinorLocator

import numpy as np
import seaborn as sns

from utils import nv_demon
from utils import nvlink
from utils import square_plot


def workloads_exec_time_add_value(workload_list, name, job, gpus_list, start_time, end_time, submitted_time):
    if name not in workload_list:
        workload_list[name] = dict()
    if job not in workload_list[name]:
        workload_list[name][job] = dict()
        exec_time = end_time - start_time
        exec_time_submitted = end_time - submitted_time

        workload_list[name][job]['gpus'] = gpus_list
        workload_list[name][job]['start_time'] = start_time
        workload_list[name][job]['end_time'] = end_time
        workload_list[name][job]['submitted_time'] = submitted_time
        workload_list[name][job]['exec_time'] = exec_time
        workload_list[name][job]['exec_time_submitted'] = exec_time_submitted
    return workload_list


def get_fig_index():
    return itertools.cycle(['(c)', '(d)', '(b)', '(a)', '(e)', '(f)', '(g)', '(h)'])


def get_colors():
    return itertools.cycle(['k', 'g', 'r', 'b', 'm', 'y', 'c'])


def get_lines_format():
    return itertools.cycle(["--", "-.", ":", "-"])


def get_colors2():
    return itertools.cycle(['#f2b1bc', '#02e0bd', '#7cc8f0', '#9083de', '#07a998', '#5a71ff', '#224fc2', '#19f2fb',
                            '#8e9e1f', '#3266c8', '#2b2c08', '#975ce0', '#e1c295', '#95e4c9', '#5d160e', '#4b5241',
                            '#7a55f8', '#ac3320', '#58aa2d', '#953164'])


def get_pattern():
    return itertools.cycle(['/', 'o', 'x', '-', '+', 'O', '.', '*'])

plt.rcParams['ps.useafm'] = True
plt.rcParams['pdf.use14corefonts'] = True
plt.rcParams['text.usetex'] = True #Let TeX do the typsetting
plt.rcParams['font.family'] = 'Times New Roman' # ... for regular text

folders = list()
for root, directories, files in os.walk("../../results/"):
    if not "real" in root:
        if 'placement_stats.json' in files:
            print "folder: ", root, files
            folders.append(root + "/")

sys_config = configparser.ConfigParser(delimiters=("="))
sys_config.read("../../etc/configs/sys-config.ini")

job_profiles = json.load(
                open("../../data/profiles/" + json.loads(sys_config.get("workload", "profile")) + ".json", "r"))


length = sys_config.getfloat("simulator", "length")
period = sys_config.getfloat("simulator", "period")
digits = sys_config.getint("simulator", "digits")
window_min = sys_config.getfloat("plot", "window_min")
window_max = sys_config.getfloat("plot", "window_max")
submissions = sys_config.getboolean("plot", "submissions")
workload_file = json.loads(sys_config.get("workload", "workload_file"))
offset = int(math.floor(window_min / period))

workloads_exec_time = dict()
ap = argparse.ArgumentParser()
ap.add_argument("-c", "--sched_config", dest="c", required=False,
                help="System configuration file", default="../../etc/configs/sched_config-")
ap.add_argument("-w", "--workload", dest="w", required=False,
                help="JSON workload file", default="../../data/")
ap.add_argument("-s", "--schedule", dest="s", required=False,
                help="JSON schedule file", default="sched_stats.json")
ap.add_argument("-p", "--placement", dest="p", required=False,
                help="JSON schedule file", default="placement_stats.json")
ap.add_argument("-t", "--stats", dest="t", required=False,
                help="JSON stats file", default="system_stats.json")
args = ap.parse_args()

with open(args.w + workload_file + ".json") as w:
    workload = json.load(w)

sns.set_context("paper", font_scale=3)

fig_indexs = get_fig_index()
postponded = False
num_gpus = 0

for result_folder in folders:
    lines_format = get_lines_format()
    colors = get_colors()
    patterns = get_pattern()
    values = result_folder.split("/")
    algo_name = values[5].split("-")

    if not postponded:
        if "bf" in algo_name:
            folders.append(result_folder)
            postponded = True
            continue
    # print algo_name
    if "utilityaware" not in algo_name:
        algo_name = algo_name[len(algo_name) - 1].upper()
    else:
        postpone = algo_name[len(algo_name) - 1]
        algo_name = algo_name[len(algo_name) - 5].upper()
        if postpone == 'True':
            algo_name += "-P"

    args = ap.parse_args()
    sched_config = configparser.ConfigParser(delimiters=("="))
    sched_config.read(args.c + algo_name + '.ini')

    args = ap.parse_args()

    with open(result_folder+args.s) as s:
        scheduler_stats = json.load(s)

    with open(result_folder+args.p) as p:
        placement_stats = json.load(p)

    with open(result_folder+args.t) as t:
        system_stats = json.load(t)

    jobs = workload
    steps = dict()
    for s, v in placement_stats.iteritems():
        steps[int(float(s))] = s
    steps = sorted(steps.iteritems(), key=lambda t: t[0], reverse=False)
    x = np.array(steps)

    ordered_jobs = []
    for job in jobs:
        ordered_jobs.append(int(job))
    ordered_jobs = sorted(ordered_jobs)

    running_job = dict()
    running_time = dict()
    utility = dict()

    steps2 = np.zeros(int(window_max), dtype=np.int)
    for step in range(int(window_max)):
        running_time[step] = dict()

    added = list()
    for step, k in enumerate(steps):
        k_str = k[1]
        k = k[0]
        if k_str not in placement_stats:
            continue

        for jid in ordered_jobs:
            jid = str(jid)

            if k not in utility:
                utility[k] = dict()
                utility[k]['job_utility'] = 0
                utility[k]['sys_utility'] = 0
                utility[k]['num_jobs'] = 0

            if jid in placement_stats[k_str]:
                submitted = float(placement_stats[k_str][jid]["submitted_time"])
                start = float(placement_stats[k_str][jid]["start_time"])
                end = float(placement_stats[k_str][jid]["end_time"])
                gpus_list =placement_stats[k_str][jid]["gpus"]

                if jid not in added:
                    workloads_exec_time = workloads_exec_time_add_value(workloads_exec_time, algo_name,
                                                                        jid, gpus_list, start, end, submitted)
                    added.append(jid)
                    for gpu in placement_stats[k_str][jid]["gpus"]:
                        if int(gpu) > num_gpus:
                            num_gpus = int(gpu)
                size = len(placement_stats[k_str][jid]["gpus"])

                if jid not in running_job:
                    running_job[jid] = np.zeros(len(steps2), dtype=np.int)

                for i in range(int(start), int(end)):
                    running_job[jid][i] = size
                    if jid not in running_time[i]:
                        running_time[i] = dict()
                    running_time[i][jid] = size

                utility[k]['job_utility'] += placement_stats[k_str][jid]['job_utility']
                utility[k]['sys_utility'] += placement_stats[k_str][jid]['sys_utility']
                utility[k]['num_jobs'] += 1

    # accumulate running gpus to plot stepped figure
    arunning = copy.deepcopy(running_job)
    for step, k_str in enumerate(steps2):
        # k_str = str(k_str)
        for m, i in enumerate(ordered_jobs):
            jid = str(i)
            if jid in running_time[step]:
                for n, j in enumerate(ordered_jobs):
                    if n >= m:
                        break
                    # j2id = str(j)
                    if jid != j:
                        if j in running_time[step]:
                            arunning[jid][step] += running_job[str(j)][step]

    """Creating the schedule graphic"""
    fig_size = (18, 10)
    fig, axs = plt.subplots(2, 1, figsize=fig_size)

    axs[0].set_xlim([0, window_max+30])
    axs[0].set_ylim([0, 4])
    maxy = 0
    previous_submitted_time = 0
    submitted_order = False
    for id, job in workloads_exec_time[algo_name].iteritems():
        """Plot the square into the graphic"""
        color = colors.next()
        pattern = patterns.next()
        axs[0] = square_plot.add_job_square(axs[0], id, job, pattern, color)

        """Plot a label into the graphic to indicate the job arrival time"""
        label = "J" + str(id)
        xposition = job['submitted_time'] - 2.3
        yposition = num_gpus + 1
        if int(id) == 0:
            yposition = 4

        elif int(id) == 1:
            yposition = 4.2

        elif int(id) == 3:
            yposition = 4.4

        elif int(id) == 4:
            yposition = 4.6

        elif int(id) == 5:
            yposition = 4.8

        previous_submitted_time = job['submitted_time']

    fig_index = fig_indexs.next()
    axs[0] = square_plot.add_text(axs[0], 450, (num_gpus + 1.5), fig_index, 48)

    axs[0].set_xlim([0, window_max])
    axs[0].xaxis.set_major_locator(matplotlib.ticker.MultipleLocator(48))
    axs[0].yaxis.set_major_locator(matplotlib.ticker.MultipleLocator(1))
    axs[0].yaxis.set_minor_locator(AutoMinorLocator(2))
    axs[0].grid(b=True, which='major', color='w', linewidth=1.0)
    axs[0].grid(b=True, which='minor', color='w', linewidth=0.3)
    yticks = list()
    for i in range(num_gpus+1):
        yticks.append(i)

    axs[0].yaxis.set_ticklabels(yticks, minor=True)
    axs[0].yaxis.set_ticklabels([], minor=False)

    for tick in axs[0].yaxis.get_minor_ticks():
        tick.label.set_fontsize(52)

    axs[0].set_title(algo_name.upper(), fontsize=50)
    axs[0].set_ylabel('GPU ID', fontsize=52)
    axs[0].tick_params(labelsize=58)
    axs[0].legend(loc='upper right', ncol=1,  fancybox=True, shadow=True,
                  prop={'size': 48}, labelspacing=0.1, handlelength=0.6, columnspacing=0.05,
                  handleheight=0.6, borderpad=0.05,
                  bbox_to_anchor=(1.01, 1.16))

    _ = [tick.label.set_fontsize(18) for tick in axs[0].xaxis.get_major_ticks()]
    axs[0].set_xticklabels([])


    """AX1"""
    utility = OrderedDict(sorted(utility.items(), key=lambda t: t[0], reverse=False))

    color = colors.next()
    x = [int(s) for s, _ in utility.iteritems()][:-offset or None]
    ju = [float(s['job_utility']) / float(s['num_jobs']) for _, s in utility.iteritems()][offset:]
    sns.tsplot(time=x, data=ju, condition="Mean Job Utility", ax=axs[1], color="r", linestyle="--")
    axs[1].set_ylabel('Utility', fontsize=56)
    axs[1].tick_params(labelsize=58)
    axs[1].legend(prop={'size': 48})
    axs[1].set_ylim([0, 1.1])
    axs[1].set_xlim([0, window_max])
    axs[1].xaxis.set_major_locator(matplotlib.ticker.MultipleLocator(48))
    axs[1].yaxis.set_major_locator(matplotlib.ticker.MultipleLocator(0.2))
    axs[1].grid(b=True, which='major', color='w', linewidth=1.0)
    axs[1].grid(b=True, which='minor', color='w', linewidth=0.3)

    # """AX2"""
    # color = colors.next()
    # x = [s["curr_time"] for s in system_stats][:-offset or None]
    # f = [s["frag"] for s in system_stats][offset:]
    # sns.tsplot(time=x, data=f, condition="Sys Fragmentation", ax=axs[2], color=color, linestyle=":")
    # axs[2].set_ylim([-0.05, 1.1])
    # axs[2].set_xlim([0, window_max])
    # axs[2].xaxis.set_major_locator(matplotlib.ticker.MultipleLocator(32))
    # axs[2].yaxis.set_major_locator(matplotlib.ticker.MultipleLocator(0.4))
    #
    # axs[2].grid(b=True, which='major', color='w', linewidth=1.0)
    # axs[2].grid(b=True, which='minor', color='w', linewidth=0.3)
    # axs[2].set_ylabel('Frag.', fontsize=36)
    # axs[2].tick_params(labelsize=58)
    # axs[2].legend(prop={'size': 28}, loc="upper left")
    # _ = [tick.label.set_fontsize(17) for tick in axs[2].xaxis.get_major_ticks()]

    # if "P" in str(algo_name):
    #     axs[2].set_xlabel('Time (s)', fontsize=36)
    # axs[2].tick_params(labelsize=58)
    # for tick in axs[2].get_xticklabels():
    #     tick.set_rotation(55)

    if "P" in str(algo_name):
        axs[1].set_xlabel('Time (s)', fontsize=56)
    axs[1].tick_params(labelsize=58)
    for tick in axs[1].get_xticklabels():
        tick.set_rotation(55)

    plt.subplots_adjust(wspace=0, hspace=0.05)
    folder = folders[0] + "../plot_with_all_algo/"
    if not os.path.exists(folder):
        os.makedirs(folder)
    plt.savefig(folder + str(algo_name).replace("AWARE", "", -1) + '.pdf', bbox_inches='tight')

print "##################"
for time_type in ['exec_time', 'exec_time_submitted']:
    lines_format = get_lines_format()
    colors = get_colors()
    fig, ax = plt.subplots(1, 1, figsize=fig_size)
    normalized_time_submited = dict()
    normalized_time = dict()
    for algo_name, jobs in workloads_exec_time.iteritems():
        for job, time in jobs.iteritems():
            job_info = workload[str(job)]
            job_type = job_info['type']
            job_size = str(job_info['size'])
            job_num_gpus = str(job_info['gpus'])
            profile_time = float(job_profiles['solo'][job_type][job_size]['num_gpus'][job_num_gpus]["intra-socket"])

            print algo_name, job, time[time_type], profile_time
            norm = profile_time/float(time[time_type])
            if norm >= 1:
                norm = 1
            normalized_time[job] = norm

        normalized_time = OrderedDict(sorted(normalized_time.items(), key=lambda t: t[1], reverse=False))

        format = lines_format.next()
        color = colors.next()
        x = [int(i) for i in range(len(normalized_time))]
        j = [t for _, t in normalized_time.iteritems()]
        sns.tsplot(time=x, data=j, condition=algo_name, ax=ax, color=color, linestyle=format)
        # ax.set_title(time_type)

    ax.set_ylim([0.2, 1.1])
    ax.set_ylabel('Exec. time norm to Ideal', fontsize=56)
    ax.set_xlabel('Workloads (from worst to best)', fontsize=56)
    ax.tick_params(labelsize=58)
    ax.legend(prop={'size': 48}, loc="lower right")

    fig_index = fig_indexs.next()
    ax = square_plot.add_text(ax, 4.5, 1.2, fig_index, 48)

    if 'submitted' in time_type:
        ax.set_title("JOB'S QOS + WAITING TIME", fontsize=56)
    else:
        ax.set_title("JOB'S QOS", fontsize=56)
    folder = folders[0] + "../plot_with_all_algo/"
    if not os.path.exists(folder):
        os.makedirs(folder)
    plt.savefig(folder + str(time_type).replace("ubmitted", "", -1) + '.pdf', bbox_inches='tight')

# plt.show()