# # !/usr/bin/python
# # -*- coding: utf-8 -*-
# #
# # simu-plot -- Plot a workload schedule
# #
# # Given a system configuration, a workload description, and a schedule as
# # generated by simulation, this program generates a plot displaying the
# # amount of gpus used by each job over time, as well as submission times
# # for each job in the workload.
# #
# # Copyright Â© 2017 Marcelo Amaral <marcelo.amaral@bsc.es>
#
import argparse
import configparser
import copy
import itertools
import json
import math
import matplotlib
import matplotlib.pyplot as plt
import os
from collections import OrderedDict

import numpy as np
import pandas as pd
import seaborn as sns

from src.plot.utils import nv_demon
from src.plot.utils import nvlink


def workloads_exec_time_add_value(workload_list, name, job, exec_time, exec_time_submitted, submitted_time):
    if name not in workload_list:
        workload_list[name] = dict()
    if job not in workload_list[name]:
        workload_list[name][job] = dict()

        workload_list[name][job]['exec_time'] = exec_time
        workload_list[name][job]['exec_time_submitted'] = exec_time_submitted
        workload_list[name][job]['submitted_time'] = submitted_time
    return workload_list


def get_colors():
    return itertools.cycle(['k', 'g', 'r', 'b', 'm', 'y', 'c'])


def get_lines_format():
    return itertools.cycle(["--", "-.", ":", "-"])

folders = list()
for root, directories, files in os.walk("../../results/"):
    if "real" in root:
        if 'placement_stats.json' in files:
            folders.append(root + "/")

sys_config = configparser.ConfigParser(delimiters=("="))
sys_config.read("../../etc/configs/sys-config.ini")

job_profiles = json.load(
                open("../../data/profiles/" + json.loads(sys_config.get("workload", "profile")) + ".json", "r"))


# logging.basicConfig(format="%(message)s", level=logging.ERROR)
length = sys_config.getfloat("simulator", "length")
period = sys_config.getfloat("simulator", "period")
digits = sys_config.getint("simulator", "digits")
window_min = sys_config.getfloat("plot", "window_min")
window_max = sys_config.getfloat("plot", "window_max")
submissions = sys_config.getboolean("plot", "submissions")
workload_file = json.loads(sys_config.get("workload", "workload_file"))
offset = int(math.floor(window_min / period))

workloads_exec_time = dict()
ap = argparse.ArgumentParser()
ap.add_argument("-c", "--sched_config", dest="c", required=False,
                help="System configuration file", default="../../etc/configs/sched_config-")
ap.add_argument("-w", "--workload", dest="w", required=False,
                help="JSON workload file", default="../../data/")
ap.add_argument("-s", "--schedule", dest="s", required=False,
                help="JSON schedule file", default="sched_stats.json")
ap.add_argument("-p", "--placement", dest="p", required=False,
                help="JSON schedule file", default="placement_stats.json")
ap.add_argument("-t", "--stats", dest="t", required=False,
                help="JSON stats file", default="system_stats.json")
args = ap.parse_args()

with open(args.w + workload_file + ".json") as w:
    workload = json.load(w)

postponded = False
sns.set_context("paper", font_scale=2)

for result_folder in folders:
    lines_format = get_lines_format()
    colors = get_colors()
    values = result_folder.split("/")
    algo_name = values[5].split("-")

    if not postponded:
        if "bf" in algo_name:
            folders.append(result_folder)
            postponded = True
            continue
    # print algo_name
    if "utilityaware" not in algo_name:
        algo_name = algo_name[len(algo_name) - 1].upper()
    else:
        postpone = algo_name[len(algo_name) - 1]
        algo_name = algo_name[len(algo_name) - 5].upper()
        if postpone == 'True':
            algo_name += "-P"

    args = ap.parse_args()
    sched_config = configparser.ConfigParser(delimiters=("="))
    # print args.c + algo_name + '.ini'
    sched_config.read(args.c + algo_name + '.ini')

    args = ap.parse_args()

    with open(result_folder+args.s) as s:
        scheduler_stats = json.load(s)

    with open(result_folder+args.p) as p:
        placement_stats = json.load(p)

    with open(result_folder+args.t) as t:
        system_stats = json.load(t)

    jobs = workload
    steps = dict()
    for s, v in placement_stats.iteritems():
        steps[int(float(s))] = s
    steps = sorted(steps.iteritems(), key=lambda t: t[0], reverse=False)
    x = np.array(steps)

    ordered_jobs = []
    for job in jobs:
        ordered_jobs.append(int(job))
    ordered_jobs = sorted(ordered_jobs)

    running_job = dict()
    running_time = dict()
    color = dict()
    utility = dict()

    steps2 = np.zeros(int(window_max), dtype=np.int)
    for step in range(int(window_max)):
        running_time[step] = dict()

    added = list()
    for step, k in enumerate(steps):
        k_str = k[1]
        k = k[0]
        if k_str not in placement_stats:
            continue

        # for jid in placement_stats[k_str]:
        for jid in ordered_jobs:
            jid = str(jid)

            if k not in utility:
                utility[k] = dict()
                utility[k]['job_utility'] = 0
                utility[k]['sys_utility'] = 0
                utility[k]['num_jobs'] = 0

            if jid in placement_stats[k_str]:
                submitted = float(placement_stats[k_str][jid]["submitted_time"])
                start = float(placement_stats[k_str][jid]["start_time"])
                end = float(placement_stats[k_str][jid]["end_time"])
                if jid not in added:
                    # print algo_name, jid, placement_stats[k_str][jid]["exec_time"], end - submitted
                    workloads_exec_time = workloads_exec_time_add_value(workloads_exec_time, algo_name, jid,
                                                  placement_stats[k_str][jid]["exec_time"],
                                                  (end - submitted), submitted)
                    added.append(jid)
                color[jid] = placement_stats[k_str][jid]['color']
                size = len(placement_stats[k_str][jid]["gpus"])

                if jid not in running_job:
                    running_job[jid] = np.zeros(len(steps2), dtype=np.int)

                for i in range(int(start), int(end)):
                    running_job[jid][i] = size
                    if jid not in running_time[i]:
                        running_time[i] = dict()
                    running_time[i][jid] = size

                utility[k]['job_utility'] += placement_stats[k_str][jid]['job_utility']
                utility[k]['sys_utility'] += placement_stats[k_str][jid]['sys_utility']
                utility[k]['num_jobs'] += 1

    # accumulate running gpus to plot stepped figure
    arunning = copy.deepcopy(running_job)
    for step, k_str in enumerate(steps2):
        # k_str = str(k_str)
        for m, i in enumerate(ordered_jobs):
            jid = str(i)
            if jid in running_time[step]:
                for n, j in enumerate(ordered_jobs):
                    if n >= m:
                        break
                    # j2id = str(j)
                    if jid != j:
                        if j in running_time[step]:
                            arunning[jid][step] += running_job[str(j)][step]

    fig_size = (10, 10)
    fig, axs = plt.subplots(4, 1, figsize=fig_size)
    # sns.set_style("whitegrid")
    # sns.set_style("ticks")

    df = pd.DataFrame(arunning)
    ax = df.plot(kind='area', linewidth=0.0, ax=axs[0], legend=False)
    jobs_submitted_time = sorted([job[1]["submitted_time"] for job in workloads_exec_time[algo_name].iteritems()][offset:])
    for job, sb_time in enumerate(jobs_submitted_time):
        # color = jobs[str(job)]["color"]
        ax.annotate('.', xy=(sb_time, 4),  xytext=(sb_time, 4),
                    arrowprops=dict(arrowstyle="->", connectionstyle="arc3"),
                    )

    # ax = df.plot(kind='area', legend=False)
    ax.set_ylabel('# GPUs')
    # ax.set_xlabel('Time (s)')
    ax.set_title(algo_name.upper(), fontsize=14)
    # ax.legend(prop={'size': 13})
    ax.set_xlim([0, window_max])
    # ax.xaxis.set_major_locator(matplotlib.ticker.MultipleLocator(int(window_max)/10))
    ax.xaxis.set_major_locator(matplotlib.ticker.MultipleLocator(50))
    ax.yaxis.set_major_locator(matplotlib.ticker.MultipleLocator(1))
    _ = [tick.label.set_fontsize(12) for tick in axs[0].xaxis.get_major_ticks()]
    axs[0].set_xticklabels([])


    """Collect the metrics"""
    last_step = float(steps[len(steps)-1][1])
    total_h_band, total_p2p_band_01, total_p2p_band_23 = nvlink.get_bandwidth(result_folder + "/logs/", percentage=False)

    """AX1.1"""
    average_gpu_utilization = nv_demon.get_avg_gpu_utilization(result_folder + "/logs/")
    average_mem_utilization = nv_demon.get_avg_gpu_mem_utilization(result_folder + "/logs/")

    x = [i * 7.2 for i in range(len(average_gpu_utilization))]
    sns.tsplot(time=x, data=average_gpu_utilization, condition="Computing", color="k", linestyle=":", ax=axs[1])
    # x = [i * 7.2 for i in range(len(average_mem_utilization))]
    # sns.tsplot(time=x, data=average_mem_utilization, condition="Occu. Memory", color="c", linestyle="-.", ax=axs[1])
    # ax.set_xlabel('Time (s)', alpha=0.8)
    axs[1].set_ylabel('GPU Usage', alpha=0.8)
    axs[1].set_ylim([0.0, 1.1])
    axs[1].set_xlim([0, window_max])
    axs[1].legend(prop={'size': 11}, loc="upper right")
    _ = [tick.label.set_fontsize(12) for tick in axs[1].xaxis.get_major_ticks()]
    axs[1].xaxis.set_major_locator(matplotlib.ticker.MultipleLocator(50))
    axs[1].set_xticklabels([])

    """AX1.2"""
    utility = OrderedDict(sorted(utility.items(), key=lambda t: t[0], reverse=False))
    # x = [int(s) for s, _ in utility.iteritems()][:-offset or None]
    x = [i for i in range(len(utility))]
    ju = [float(s['job_utility']) / float(s['num_jobs']) for _, s in utility.iteritems()][offset:]
    sns.tsplot(time=x, data=ju, condition="Mean Job Utility", ax=axs[2], color="r", linestyle="--")
    axs[2].set_ylabel('Utility', alpha=0.8)
    axs[2].set_ylim([0.0, 1.1])
    axs[2].set_xlim([0, window_max])
    axs[2].legend(prop={'size': 11}, loc="upper right")
    _ = [tick.label.set_fontsize(12) for tick in axs[2].xaxis.get_major_ticks()]
    axs[2].set_xticklabels([])
    axs[2].xaxis.set_major_locator(matplotlib.ticker.MultipleLocator(50))

    """AX2"""
    color = colors.next()
    # x = [i * 5 for i in range(len(total_h_band))]
    x = [i * 7.8 for i in range(len(total_h_band))]
    sns.tsplot(time=x, data=total_h_band, condition="NVLink HOST<->GPUS", color="g", linestyle=":", ax=axs[3])
    sns.tsplot(time=x, data=total_p2p_band_01, condition="NVLink GPU0<->GPU1", color="b", linestyle="--", ax=axs[3])
    sns.tsplot(time=x, data=total_p2p_band_23, condition="NVLink GPU2<->GPU3", color="k", linestyle="-.", ax=axs[3])
    axs[3].set_ylabel('GB/s', alpha=0.8)
    axs[3].set_xlabel('Time (s)')
    axs[3].set_ylim([0, 45])
    axs[3].set_xlim([0, window_max])
    axs[3].legend(prop={'size': 11}, loc="upper left")
    # _ = [tick.label.set_fontsize(12) for tick in axs[3].xaxis.get_major_ticks()]
    axs[3].xaxis.set_major_locator(matplotlib.ticker.MultipleLocator(50))
    axs[3].yaxis.set_major_locator(matplotlib.ticker.MultipleLocator(10))

    folder = result_folder + "plot/"
    if not os.path.exists(folder):
        os.makedirs(folder)
    plt.savefig(folder + str(algo_name).replace("AWARE", "", -1) + '.pdf', bbox_inches='tight')

print "##################"
for time_type in ['exec_time', 'exec_time_submitted']:
    lines_format = get_lines_format()
    colors = get_colors()
    fig, ax = plt.subplots(1, 1, figsize=fig_size)
    normalized_time_submited = dict()
    normalized_time = dict()
    for algo_name, jobs in workloads_exec_time.iteritems():
        for job, time in jobs.iteritems():
            print algo_name, job, time['exec_time'], time[time_type]
            job_info = workload[str(job)]
            job_type = job_info['type']
            job_size = str(job_info['size'])
            job_num_gpus = str(job_info['gpus'])
            print "job: ", job_type, " size: ", job_size, " gpus: ", job_num_gpus
            print job_profiles['solo'][job_type]
            print job_profiles['solo'][job_type][job_size]['num_gpus']
            profile_time = float(job_profiles['solo'][job_type][job_size]['num_gpus'][job_num_gpus]["intra-socket"])

            norm = profile_time/float(time[time_type])
            if norm >= 1:
                norm = 1
            normalized_time[job] = norm
            print "job: ", job_type, " size: ", job_size, " gpus: ", job_num_gpus, " time: ", profile_time, \
                " norm" + time_type + ": ", norm
            print ""

        normalized_time = OrderedDict(sorted(normalized_time.items(), key=lambda t: t[1], reverse=False))

        format = lines_format.next()
        color = colors.next()
        x = [int(i) for i in range(len(normalized_time))]
        j = [t for _, t in normalized_time.iteritems()]
        sns.tsplot(time=x, data=j, condition=algo_name, ax=ax, color=color, linestyle=format)
        # ax.set_title(time_type)

    ax.set_ylim([0.2, 1.1])
    ax.set_ylabel('Speedup norm to Ideal Placement')
    ax.set_xlabel('Workloads (from worst to best)')
    ax.legend(prop={'size': 13}, loc="lower right")
    if 'submitted' in time_type:
        ax.set_title("JOB SUBMITTED PLUS EXEC. TIME", fontsize=14)
    else:
        ax.set_title("ONLY JOB EXEC. TIME", fontsize=14)
    folder = folders[0] + "../plot_with_all_algo/"
    if not os.path.exists(folder):
        os.makedirs(folder)
    plt.savefig(folder + str(time_type).replace("ubmitted", "", -1) + '.pdf', bbox_inches='tight')

plt.show()